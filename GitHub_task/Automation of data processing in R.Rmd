---
title: "Automation of data processing in R"
subtitle: "BioStat 2024/25"
author: "Uvarova Victoria"
date: "`r Sys.Date()`"
output: word_document:
    toc: yes
toc-title: "Оглавление"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(psych)
library(tibble)
```

## Курс "Введение в автоматизацию обработки данных на R"

[ссылка на курс](https://stepik.org/course/211715/syllabus){.uri}

## Функции для чтения и записи файлов

Общая функция, которая позволяет читать файлы форматов csv и tsv:

> read_delim("data/raw/data_csv.csv", delim = NULL, quote = "", na = c("","NA"), skip = 0, n_max = Inf, col_names = TRUE)

*чтобы узнать путь к файлу перетащите файл прямо в окно терминала, и его полный путь будет автоматически вставлен в командную строку*

## Расчёт базовых статистик

### Базовые статистики

> na.rm = TRUE используется в функциях для игнорирования пропущенных значений (NA) при вычислениях. Если этот аргумент установлен в TRUE, пропущенные значения будут исключены из расчётов

**Среднее арифметическое mean(x, trim = 0, na.rm = FALSE)**

trim = 0: аргумент, говорящий, сколько процентов наибольших и наименьших значений нужно убрать перед тем, как вычислять среднее

```{r mean}
mean(c(76, 65, 71, 16, 60, 29, 71, 46, 45, 41))
mean(c(1, -1, 5, -12, -12, 3, 8, -10, 0))
mean(c(-13, 19, -24, NA, 30, 64, -53, NA, 50, 31, -58, -34, -3, -34, 77), na.rm = T)
mean(c(NA, NA, NA, NA, NA, NA, 3, NA, NA), na.rm = T)
mean(c(-19, -9, 19, 5, -14, 0, 34, -8, 34, 24, -11, 8, 33, 12, -6))
mean(c(-2, 16, -3, 16, -9, 7, 31))
```

**Медиана median(x, na.rm = FALSE)**

```{r median}
median(c(-15, 71, 77, 36, 66, -21, -48, -8), na.rm = T)
median(c(19, 89, 78, 38, 8, 17, 25, 60, 8, 43, 29, 6, 62, 41, 69, 97, 61, 83, 25, 24), na.rm = T)
median(c(1, 9, NA, 88, 2, NA, 42, NA, 4, 68, NA), na.rm = T)
median(c(-91, -33, 13, 34, 34, 75, -80, -35, -90, -72, 70, 67, -100, -94, -18), na.rm = T)
median(c(-92, -50, 54, 55, 84, 52, -55, -23, 36, -11, 22, 11, -7), na.rm = T)
```

**Минимальное и максимальное значение min(x, na.rm = FALSE) max(x, na.rm = FALSE)**

```{r min-max}
min(c(68.92, 44.15, 34.2, 34.12, 37.7, 73.95, 36.9, 59.26, 31.06, 55.79, 73.92, 68.04, 53.73, 90.7, 39.66))
max(c(68.92, 44.15, 34.2, 34.12, 37.7, 73.95, 36.9, 59.26, 31.06, 55.79, 73.92, 68.04, 53.73, 90.7, 39.66))
min(c(90.48, 31.16, 44.4, 21.94, 84.37, 53.15, 81.15, 47.86, 63.23, 46.75, 102.73))
max(c(90.48, 31.16, 44.4, 21.94, 84.37, 53.15, 81.15, 47.86, 63.23, 46.75, 102.73))
min(c(17.24, 35.77, 57.57, 30.15, 43.27, 77.56, 72.19, 40.45, 46.2, 39.92))
max(c(17.24, 35.77, 57.57, 30.15, 43.27, 77.56, 72.19, 40.45, 46.2, 39.92))
min(c(48.11, 45.3, 58.42, 51.64, 62.07, 57.26, 49.69, 93.29, 81.18, 44.78, 55.1, 76.74, 58.08))
max(c(48.11, 45.3, 58.42, 51.64, 62.07, 57.26, 49.69, 93.29, 81.18, 44.78, 55.1, 76.74, 58.08))
min(c(60.22, 31.91, 72.71, 52.49, 46.21, 60.39, 60.09))
max(c(60.22, 31.91, 72.71, 52.49, 46.21, 60.39, 60.09))
```

**Квантиль quantile()**

> quantile(x, probs = seq(0, 1, 0.25), na.rm = FALSE, names = TRUE, type = 7)

```{r quantile}
quantile(c(80.94, 44.46, 46.33, 65.1, 66.42, 104.43, 53.15, 48.41, 12.88, 51.1, 43.03, 40.3, 33.71, 55.1, 22.17), probs = seq(0, 1, 0.25),type = 7)
```

**Дисперсия, cтандартное отклонение var(), sd()**

> var(x, na.rm = TRUE) несмещённая оценка дисперсии

> sd(x, na.rm = TRUE)

**Межквартильный интервал IQR()**

> IQR(x, na.rm = FALSE, type = 7)

```{r IQR}
IQR(c(80.94, 44.46, 46.33, 65.1, 66.42, 104.43, 53.15, 48.41, 12.88, 51.1, 43.03, 40.3, 33.71, 55.1, 22.17), na.rm = T, type = 7)
IQR(c(26.17, 97.73, 24.81, 53.62, 87.72, 45.19, 45.7, 69.63, 36.76, 7.17), na.rm = T, type = 7)
IQR(c(63.92, 35.85, 26.9, 48.92, 43.1, 66.94, 47.06, 56.54, 29.1, 58.88), na.rm = T, type = 7)
IQR(c(32.05, 93.85, 85.52, 56.69, 23.69, 11.29, 51.44, 63.09, 65.65, 35.73, 60.15, 30.93, -4.2), na.rm = T, type = 7)
```

**Функция, которая позволяет вычислять количество значений вектора length()**

> length(1:10)

1.  sum(!is.na(vec)): количество значений без учёта пропущенных;

2.  sum(is.na(vec)): количество пропущенных значений.

**Стандартная ошибка среднего sd(x)/sqrt(length(x))**

> без учёта пропущенных значений sum(!is.na(с))

```{r sd(x)/sqrt(length(x))}
с1 <- c(47.44, 62.44, 20.44, 72.75, 77.86, 13.74, 28.2, 50.47, 59.19, 69.04)
sd(с1)/sqrt(sum(!is.na(с1)))
с2 <- c(49.31, 44.47, 14.04, 44.43, 49.18, 40.73, 44.65, 41.91, 80.38, 80.09)
sd(с2)/sqrt(sum(!is.na(с2)))
с3 <- c(57.96, 20.81, 8.92, 14.03, 61.02, 25.69, 21.22, 49.56, 25.64, 28.31)
sd(с3)/sqrt(sum(!is.na(с3)))
с4 <- c(76.22, 65, 19.69, 29.84, 37.18, 70.93, 64.78, 61.66, 49.03, 51.56)
sd(с4)/sqrt(sum(!is.na(с4)))
с5 <- c(92.11, 56, 47.89, 62.96, 47.41, 37.05, 73.96, 53, 52.37, 85.23)
sd(с5)/sqrt(sum(!is.na(с5)))
```

### Обобщающие функции статистик

**Cводка по всем типам переменных summary()**

**psych::describe()**

> describe(x, digits = 2, na.rm = TRUE, skew = FALSE, ranges = TRUE)

**x**: датафрейм с количественными переменными; **digits** = 2: до скольки цифр округлять значения в итоговой таблице; **na.rm** = TRUE: удалять пропущенные значения в переменных; **skew** = TRUE: вычислять асимметрию; **ranges** = TRUE: вычислять размах, то есть, разницу между максимумом и минимумом.

```{r describe}
statistics <- readRDS("/Users/vika/Yandex.Disk.localized/R/BioStat2024/numeric_data.rds")
round(describe(statistics),2)
```

**table(), prop.table()**

**x**: датафрейм с n переменными; **useNA** = "always": делать ли сводку по пропущенным значениям.

> table(x, useNA = "always")

## Работа с датафреймами с помощью пакетов dplyr, tibble

### tibble вместо data.frame как формат данных

Это пайп **(%\>%)**. Если кратко: это конвейер. Эта функция берёт результат работы функции и передаёт его на вход в следующую функцию.

нужно оборачивать имена в апострофы: columnname не требует апострофов, а \`column name\` уже требует

**Просмотреть всю таблицу данных View()**

**tibble::add_column()**

Эта функция помогает просто добавить столбец с заранее заданными значениями.

> data %\>% add_column(column_name = 1:10, .before = NULL, .after = NULL)

**data**: просто имя датафрейма, к которому мы хотим добавить столбец; **column_name**: это имя нового столбца. Оно может быть любым, не только таким, как в примере; **.before**: номер уже существующего столбца, перед которым нужно поставить новый; **.after**: то же, но уже после которого нужно поставить новый. Хитрый приём: если нужно поставить переменную в конец датафрейма, то в значение можно поставить Inf.

**tibble::add_row()**

Эта работает так же, как и прошлая, но добавляет строку, а, кроме того, работа с ней существенно более неудобная, потому что нужно вручную задавать имена и значения для каждой переменной.

> data %\>% add_row(var_1 = 1, var_2 = "value", .before = NULL, .after = NULL)

**data**: просто имя датафрейма, к которому мы хотим добавить столбец; **var_1, var_2**: это имя нового столбца. Оно может быть любым, не только таким, как в примере; **.before**: номер уже существующей строки, перед которым нужно поставить новый; **.after**: то же, но уже после которого нужно поставить новый. Хитрый приём: если нужно поставить переменную в низ датафрейма, то в значение можно поставить Inf

**dplyr::row_number()**

Одна полезная функция, которая даёт возможность пронумеровать строки (добровольцев).

> data %\>% mutate(ID = row_number())

### Cклеивание

**dplyr::bind_cols()**

Мы можем сделать из двух и более таблиц одну, склеив их столбцы.

> data_1 %\>% bind_cols(data_2) %\>% bind_cols(data_3)

**dplyr::bind_rows()**

То же самое можно сделать и для склеивания строк. Один датафрейм под другим.

> data_1 %\>% bind_rows(data_2) %\>% bind_rows(data_3)

**dplyr::left_join(), dplyr::right_join(), dplyr::inner_join(), dplyr::full_join()**

Есть четыре функции, которые позволяют склеивать датафреймы по ключевым переменным (только два, назовём их x и y):

**left_join(x, y)**: включает все строки, которые есть в x, отбрасывая из y те, которых нет;

**right_join(x, y)**: включает все строки, которые есть в y, отбрасывая те, которых там нет;

**inner_join(x, y)**: включает все строки, которые есть и в x и y;

**full_join(x, y)**: просто включает все строки, которые есть хотя бы в x или y.

correct 
