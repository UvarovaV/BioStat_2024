---
title: "Automation of data processing in R"
subtitle: "BioStat 2024/25"
author: "Uvarova Victoria"
date: "`r Sys.Date()`"
output: 
  word_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(psych)
library(tibble)
library(dplyr)
library(png)
library(grid)
```

## Курс "Введение в автоматизацию обработки данных на R"

[ссылка на курс](https://stepik.org/course/211715/syllabus){.uri}

## Функции для чтения и записи файлов

Общая функция, которая позволяет читать файлы форматов csv и tsv:

> read_delim("data/raw/data_csv.csv", delim = NULL, quote = "", na = c("","NA"), skip = 0, n_max = Inf, col_names = TRUE)

*чтобы узнать путь к файлу перетащите файл прямо в окно терминала, и его полный путь будет автоматически вставлен в командную строку*

## Расчёт базовых статистик

### Базовые статистики

> na.rm = TRUE используется в функциях для игнорирования пропущенных значений (NA) при вычислениях. Если этот аргумент установлен в TRUE, пропущенные значения будут исключены из расчётов

**Среднее арифметическое mean(x, trim = 0, na.rm = FALSE)**

trim = 0: аргумент, говорящий, сколько процентов наибольших и наименьших значений нужно убрать перед тем, как вычислять среднее

```{r mean}
mean(c(76, 65, 71, 16, 60, 29, 71, 46, 45, 41))
mean(c(1, -1, 5, -12, -12, 3, 8, -10, 0))
mean(c(-13, 19, -24, NA, 30, 64, -53, NA, 50, 31, -58, -34, -3, -34, 77), na.rm = T)
mean(c(NA, NA, NA, NA, NA, NA, 3, NA, NA), na.rm = T)
mean(c(-19, -9, 19, 5, -14, 0, 34, -8, 34, 24, -11, 8, 33, 12, -6))
mean(c(-2, 16, -3, 16, -9, 7, 31))
```

**Медиана median(x, na.rm = FALSE)**

```{r median}
median(c(-15, 71, 77, 36, 66, -21, -48, -8), na.rm = T)
median(c(19, 89, 78, 38, 8, 17, 25, 60, 8, 43, 29, 6, 62, 41, 69, 97, 61, 83, 25, 24), na.rm = T)
median(c(1, 9, NA, 88, 2, NA, 42, NA, 4, 68, NA), na.rm = T)
median(c(-91, -33, 13, 34, 34, 75, -80, -35, -90, -72, 70, 67, -100, -94, -18), na.rm = T)
median(c(-92, -50, 54, 55, 84, 52, -55, -23, 36, -11, 22, 11, -7), na.rm = T)
```

**Минимальное и максимальное значение min(x, na.rm = FALSE) max(x, na.rm = FALSE)**

```{r min-max}
min(c(68.92, 44.15, 34.2, 34.12, 37.7, 73.95, 36.9, 59.26, 31.06, 55.79, 73.92, 68.04, 53.73, 90.7, 39.66))
max(c(68.92, 44.15, 34.2, 34.12, 37.7, 73.95, 36.9, 59.26, 31.06, 55.79, 73.92, 68.04, 53.73, 90.7, 39.66))
min(c(90.48, 31.16, 44.4, 21.94, 84.37, 53.15, 81.15, 47.86, 63.23, 46.75, 102.73))
max(c(90.48, 31.16, 44.4, 21.94, 84.37, 53.15, 81.15, 47.86, 63.23, 46.75, 102.73))
min(c(17.24, 35.77, 57.57, 30.15, 43.27, 77.56, 72.19, 40.45, 46.2, 39.92))
max(c(17.24, 35.77, 57.57, 30.15, 43.27, 77.56, 72.19, 40.45, 46.2, 39.92))
min(c(48.11, 45.3, 58.42, 51.64, 62.07, 57.26, 49.69, 93.29, 81.18, 44.78, 55.1, 76.74, 58.08))
max(c(48.11, 45.3, 58.42, 51.64, 62.07, 57.26, 49.69, 93.29, 81.18, 44.78, 55.1, 76.74, 58.08))
min(c(60.22, 31.91, 72.71, 52.49, 46.21, 60.39, 60.09))
max(c(60.22, 31.91, 72.71, 52.49, 46.21, 60.39, 60.09))
```

**Квантиль quantile()**

> quantile(x, probs = seq(0, 1, 0.25), na.rm = FALSE, names = TRUE, type = 7)

```{r quantile}
quantile(c(80.94, 44.46, 46.33, 65.1, 66.42, 104.43, 53.15, 48.41, 12.88, 51.1, 43.03, 40.3, 33.71, 55.1, 22.17), probs = seq(0, 1, 0.25),type = 7)
```

**Дисперсия, cтандартное отклонение var(), sd()**

> var(x, na.rm = TRUE) несмещённая оценка дисперсии

> sd(x, na.rm = TRUE)

**Межквартильный интервал IQR()**

> IQR(x, na.rm = FALSE, type = 7)

```{r IQR}
IQR(c(80.94, 44.46, 46.33, 65.1, 66.42, 104.43, 53.15, 48.41, 12.88, 51.1, 43.03, 40.3, 33.71, 55.1, 22.17), na.rm = T, type = 7)
IQR(c(26.17, 97.73, 24.81, 53.62, 87.72, 45.19, 45.7, 69.63, 36.76, 7.17), na.rm = T, type = 7)
IQR(c(63.92, 35.85, 26.9, 48.92, 43.1, 66.94, 47.06, 56.54, 29.1, 58.88), na.rm = T, type = 7)
IQR(c(32.05, 93.85, 85.52, 56.69, 23.69, 11.29, 51.44, 63.09, 65.65, 35.73, 60.15, 30.93, -4.2), na.rm = T, type = 7)
```

**Функция, которая позволяет вычислять количество значений вектора length()**

> length(1:10)

1.  sum(!is.na(vec)): количество значений без учёта пропущенных;

2.  sum(is.na(vec)): количество пропущенных значений.

**Стандартная ошибка среднего sd(x)/sqrt(length(x))**

> без учёта пропущенных значений sum(!is.na(с))

```{r sd(x)/sqrt(length(x))}
с1 <- c(47.44, 62.44, 20.44, 72.75, 77.86, 13.74, 28.2, 50.47, 59.19, 69.04)
sd(с1)/sqrt(sum(!is.na(с1)))
с2 <- c(49.31, 44.47, 14.04, 44.43, 49.18, 40.73, 44.65, 41.91, 80.38, 80.09)
sd(с2)/sqrt(sum(!is.na(с2)))
с3 <- c(57.96, 20.81, 8.92, 14.03, 61.02, 25.69, 21.22, 49.56, 25.64, 28.31)
sd(с3)/sqrt(sum(!is.na(с3)))
с4 <- c(76.22, 65, 19.69, 29.84, 37.18, 70.93, 64.78, 61.66, 49.03, 51.56)
sd(с4)/sqrt(sum(!is.na(с4)))
с5 <- c(92.11, 56, 47.89, 62.96, 47.41, 37.05, 73.96, 53, 52.37, 85.23)
sd(с5)/sqrt(sum(!is.na(с5)))
```

### Обобщающие функции статистик

**Cводка по всем типам переменных summary()**

**psych::describe()**

> describe(x, digits = 2, na.rm = TRUE, skew = FALSE, ranges = TRUE)

**x**: датафрейм с количественными переменными; **digits** = 2: до скольки цифр округлять значения в итоговой таблице; **na.rm** = TRUE: удалять пропущенные значения в переменных; **skew** = TRUE: вычислять асимметрию; **ranges** = TRUE: вычислять размах, то есть, разницу между максимумом и минимумом.

```{r describe}
statistics <- readRDS("numeric_data.rds")
round(describe(statistics),2)
```

**table(), prop.table()**

**x**: датафрейм с n переменными; **useNA** = "always": делать ли сводку по пропущенным значениям.

> table(x, useNA = "always")

## Работа с датафреймами с помощью пакетов dplyr, tibble

### tibble вместо data.frame как формат данных

Это пайп **(%\>%)**. Если кратко: это конвейер. Эта функция берёт результат работы функции и передаёт его на вход в следующую функцию.

нужно оборачивать имена в апострофы: columnname не требует апострофов, а \`column name\` уже требует

**Просмотреть всю таблицу данных View()**

**tibble::add_column()**

Эта функция помогает просто добавить столбец с заранее заданными значениями.

> data %\>% add_column(column_name = 1:10, .before = NULL, .after = NULL)

**data**: просто имя датафрейма, к которому мы хотим добавить столбец; **column_name**: это имя нового столбца. Оно может быть любым, не только таким, как в примере; **.before**: номер уже существующего столбца, перед которым нужно поставить новый; **.after**: то же, но уже после которого нужно поставить новый. Хитрый приём: если нужно поставить переменную в конец датафрейма, то в значение можно поставить Inf.

**tibble::add_row()**

Эта работает так же, как и прошлая, но добавляет строку, а, кроме того, работа с ней существенно более неудобная, потому что нужно вручную задавать имена и значения для каждой переменной.

> data %\>% add_row(var_1 = 1, var_2 = "value", .before = NULL, .after = NULL)

**data**: просто имя датафрейма, к которому мы хотим добавить столбец; **var_1, var_2**: это имя нового столбца. Оно может быть любым, не только таким, как в примере; **.before**: номер уже существующей строки, перед которым нужно поставить новый; **.after**: то же, но уже после которого нужно поставить новый. Хитрый приём: если нужно поставить переменную в низ датафрейма, то в значение можно поставить Inf

**dplyr::row_number()**

Одна полезная функция, которая даёт возможность пронумеровать строки (добровольцев).

> data %\>% mutate(ID = row_number())

### Cклеивание

**dplyr::bind_cols()**

Мы можем сделать из двух и более таблиц одну, склеив их столбцы.

> data_1 %\>% bind_cols(data_2) %\>% bind_cols(data_3)

**dplyr::bind_rows()**

То же самое можно сделать и для склеивания строк. Один датафрейм под другим.

> data_1 %\>% bind_rows(data_2) %\>% bind_rows(data_3)

**dplyr::left_join(), dplyr::right_join(), dplyr::inner_join(), dplyr::full_join()**

Есть четыре функции, которые позволяют склеивать датафреймы по ключевым переменным (только два, назовём их x и y):

**left_join(x, y)**: включает все строки, которые есть в x, отбрасывая из y те, которых нет;

**right_join(x, y)**: включает все строки, которые есть в y, отбрасывая те, которых там нет;

**inner_join(x, y)**: включает все строки, которые есть и в x и y;

**full_join(x, y)**: просто включает все строки, которые есть хотя бы в x или y.

### Группировка

**dplyr::group_by()**

Данные могут быть разделены на группы, которые стоит анализировать отдельно.

> data %\>% group_by(column_name)

Функция разбивает датафрейм на список датафреймов по указанным группам

**base::split()**

Группировка по строкам

**dplyr::rowwise()**

### Выбор столбцов

```{r}
data <- read_delim("data_tsv.tsv", delim = NULL, quote = "", na = c("","NA"), skip = 0, n_max = Inf, col_names = TRUE)
data %>%
  glimpse()
```

**dplyr::select(), where()**

Первый глагол и один из самых важных: select(). С его помощью мы просто выбираем переменные.

*если ваши имена содержат кириллические символы, пробелы, иные символы (пунктуацию), обязательно оформляйте имена в кавычки (" ")*

```{r}
`Базовый select` <- readPNG("Базовый select.png")
grid.newpage()
grid.raster(`Базовый select`)
```

```{r}
data %>% select("Группа крови", "Возраст") 
```

Мы можем выбрать все переменные, кроме определённых (отрицательный выбор):

```{r}
data %>% select(!"Группа крови") 
```

Мы можем выбирать переменные не только по названиям, но и с помощью логический функций, возвращающих TRUE или FALSE. Применяя её, мы получаем вектор таких значений, из которых функция select() выбирает те, что имеют значение TRUE. Например, так мы можем выбрать только количественные переменные. Так же можем выбирать и любые другие типы с помощью функций is.factor, is.character и прочих.

Выбор группы и всех количественных переменных:

```{r}
data %>%
  select("Группа", where(is.numeric)) 
```

Сложная функция для выбора (**не работает**):

```{r}
data %>%
  select("Группа", where(is.numeric) & function(x) mean(x, na.rm = T) > 10)
```

Оператор & не применяется для комбинирования условий в select().

Сложная функция для выбора (**работает без выбора "Группа"**):

```{r}
data %>%
  select(where(is.numeric)) %>% select(where(function(x) mean(x) > 10))
```

Сложная функция для выбора (**работает без выбора "Группа"**):

```{r}
data %>%
  select(x, where(function(x) is.numeric(x) & mean(x, na.rm = TRUE) > 3.5))
```

Сложная функция для выбора (**работает**):

```{r}
data %>%
  select("Группа", where(~ is.numeric(.) && mean(., na.rm = TRUE) > 10))
```

**Пересечение и объединение условий, отрицание условий**

**tidyselect::all_of(), tidyselect::any_of()**

Приоритет логических операторов от высшего к низшему.

x \< y, x \> y, x \<= y, x =\> y, x == y, x != y (операторы сравнения)

!x (логическое НЕ)

x & y (логическое И)

x \| y (логическое ИЛИ)

**tidyselect::everything()** "все остальные столбцы, кроме тех, которые уже были указаны". Например, так мы можем выбрать определённые столбцы, а потом просто все остальные, которые будут выведены в том порядке, в котором они были, за исключением тех, что мы уже явно взяли.

```{r}
data %>%
  select("Пол", "Эритроциты_E1", everything())
```

**Выбор с одновременным изменением имён**

```{r}
data %>%
  select("Эритроциты__Визит 1" = "Эритроциты_E1")
```

### Выбор строк

**dplyr::slice()** Для того, чтобы выбрать определённые строки, следует использовать slice().

```{r}
data %>%
  slice(1:10)
```

**dplyr::filter()** Второй важнейший глагол dplyr --- filter(). Он делает именно то, что значит --- фильтрует датафрейм по заданным условиям.

```{r}
data %>%
  filter(`Пол` == "Женский")
```

Сложная фильтрация:

```{r}
data %>%
  filter(`Группа крови` %in% c("A (II)","O (I)") & `Группа` !="Группа 1")
```

Для того, чтобы, фильтруя по категориальной переменной, выбрать сразу несколько значений, используется функция %in%.

Фильтрация по отрезку количественной переменной:

```{r}
data %>%
  filter(between(`Возраст`, 31, 34))
```

С количественной переменной не стоит использовать %in%, лучше использовать between(). Эта функция помогает выбрать в переменной только те значения, которые включены в отрезок (и минимум, и максимум включены в этот отрезок).

Мягкая фильтрация около числа:

```{r}
data %>%
  filter(near(Эозинофилы_E1, 3.38, tol = 0.1))
```

В примере выше мы отфильтровали датасет по значению эозинофилов на первом визите так, чтобы значения были примерно 3.38 ± 0.1.

**Использование if_any() и if_all() для фильтрации сразу по нескольким переменным** Фильтруем данные по условию, чтобы все переменные, содержащие в названии "Базофилы", имели значение строго больше 1.5:

```{r}
data %>%
  filter(if_all(.cols = contains("Базофилы"), .fns = function(x) x > 1.5))
```

Теперь условие в том, чтобы хотя бы одна из этих переменных имела значение строго больше 1.5:

```{r}
data %>%
  filter(if_any(.cols = contains("Базофилы"), .fns = function(x) x > 1.5))
```

Фильтрация с группированным датафреймом. Мы можем фильтровать данные и относительно каждой группы:

```{r}
data %>%
  group_by(`Группа`) %>%
  filter (`Возраст` > 36)
```

### Мутация переменных

**dplyr::mutate()** помогает изменять переменные и создавать новые на основе уже существующих.

Базовый пример создания индикаторной переменной:

```{r}
data %>%
  mutate(`Женщины с четвертой группой крови` = ifelse(`Пол` == "Женский" & `Группа крови` == "AB (IV)", "Да", "Нет")) %>%
  select(`Женщины с четвертой группой крови`, everything()) %>%
  arrange(`Женщины с четвертой группой крови`)
```

шпаргалка для количественных переменных:

```{r}
tibble(var_1 = 1:10, var_2 = var_1 + 1.123) %>%
  mutate(var_sum = var_1 + var_2,
        var_minus = var_1 - var_2,
        var_multiple = var_1 * var_2,
        var_divide = var_1 / var_2,
        var_1_log = log(var_1),
        var_1_log1p = log1p(var_1),
        var_1_exp = exp(var_1_log),
        var_1_exm1 = expm1(var_1_log1p),
        var_2_round = round (var_2, 2),
        var_2_ceil = ceiling(var_2),
        var_2_floor = floor (var_2)) %>%
glimpse()
```

+: сложение; -: вычитание; `*`: умножение; /: деление; log(): натуральный логарифм; log1p(): тот же логарифм, но прибавляющий к исходному значению единицу, чтобы избавиться от проблемы нуля; exp(): возведение в экспоненту; expm1(): возведение в экспоненту из значения минус один; round(): округление до заданного количества знаков после запятой; ceiling(): округление до ближайшего максимального целого числа; floor(): округление до ближайшего минимального целого числа.

**dplyr::case_when()** создание переменной по нескольким условиям
```{r}
data %>%
  mutate(`Возрастная группа` = case_when(`Возраст` < 20 ~ "< 20",
                                         between(`Возраст`, 20, 30) ~ "20 - 30",
                                         `Возраст` > 30 ~ "> 30") %>% as.factor()) %>%
  select(`Возраст`, `Возрастная группа`)
```

**tidyr::na_if(), tidyr::replace_na()** Чтобы заменить пропущенные значения каким-нибудь определённым значением (например, вместо NA сделать "Нет данных"), используется функция replace_na().
```{r}
data %>%
  mutate(`Группа крови` = `Группа крови` %>% as.character() %>% replace_na("Нет данных") %>% as.factor())
```
Можно заметить, что тут всё не так просто. Мы меняем типы. Это нужно сделать, если переменная, в которой мы собираемся заменять значения, факторная, иначе будет возвращена ошибка. Выход — поменять тип на character, а потом обратно на factor.

Предположим, у нас не может быть в данных третьей группы крови, и мы хотим заменить её на пропущенное значение. Выше пример того, как мы можем это сделать:
```{r}
data %>%
  mutate(`Группа крови` = `Группа крови` %>% na_if("B (III)"))
```

**NULL** как удаление переменной. Мы можем легко удалить переменную через mutate():
```{r}
data %>%
  mutate(`Группа` = NULL)
```

**Функция across()** для применения других функций к подмножеству переменных. В этой функции два основных аргумента: выбор столбцов, к которым будем применять функции; сама функция. Здесь мы применили функцию нормализации ко всем количественным переменным:
```{r}
data %>%
  mutate(across(where(is.numeric), function(x) (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)))
```

А здесь только к тем, которые в названии содержат "E1":
```{r}
data %>%
  mutate(across(contains("E1"), function(x) (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)))
```

здесь мы нормализуем только те переменные, среднее которых строго меньше 10 (**не работает**): 
```{r}
data %>%
  mutate(across(function(x) mean(x, na.rm = TRUE) < 10, function(x) (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)))
```

Итерация по строкам **rowwise()**
Изредка нужно итерироваться не по столбцам, а по строкам. Например, найти средние значения базофилов за оба визита. Вспомним функцию rowwise() и, наконец-то, применим её на практике.
```{r}
data %>%
  rowwise() %>%
  mutate(`Среднее по базофилам` = mean(c_across(contains("Базофилы")))) %>%
  ungroup() %>%
  select(contains("Базофил"))
```
ungroup() отменяет действие rowwise()

**Применение mutate() к сгруппированным датафреймам**
Иногда нужно мутировать новые переменные по сгруппированным датафреймам. Например, мы хотим сделать переменную, в которой для каждой группы будет рассчитано значение определённой переменной за вычетом среднего по этой группе.
```{r}
data %>%
  group_by(`Группа`) %>%
  mutate(across(contains("Базофилы"), function(x) x - mean(x, na.rm = TRUE))) %>%
  ungroup() %>%
  select(`Группа`, contains("Базофилы"))
```

### Переименование

### Сортировка

### Повороты датафреймов

### Выбор уникальных сочетаний

### Разделение и склеивание

### Расчёт статистик

## Пакет flextable
**flextable::flextable()** Предназначение пакета flextable — создавать из датафреймов таблицы, которые можно напрямую печатать в html, pdf, использовать в документах Word, PowerPoint. После этого мы применяем общую тему. Она устанавливает общие границы, внешний вид таблицы. Чаще всего используется theme_box(), на втором месте стоит theme_apa().